<template id="sticky-mini-title-template">
  <div class="sticky-mini-title">
    <div class="sticky-mini-title-content">
      {{< var pub.title>}}
    </div>
  </div>
</template>

<style>
  /* Container setup */
  .navbar-container {
    display: flex !important;
    flex-direction: column !important;
  }

  /* Wrapper for existing content to preserve layout */
  .navbar-main-content {
    display: flex;
    width: 100%;
    justify-content: space-between;
    align-items: center;
  }

  /* Preserve original spacing classes */
  .navbar-main-content .mx-auto {
    margin-left: auto !important;
    margin-right: auto !important;
  }

  .navbar-main-content .me-auto {
    margin-right: auto !important;
  }

  .navbar-main-content .ms-auto {
    margin-left: auto !important;
  }

  /* Base styling for persistent element with collapsible height */
  .sticky-mini-title {
    color: white;
    transform: translateY(-100%);
    height: 0rem;
    opacity: 1;
    line-height: 3rem;
    padding: 0 1rem;
    width: 100%;
    background-color: #3b6179;
    order: 2;
    /* Stretch across screen, outside its div */
    position: relative;
    left: 0%;
    right: 50%;
    margin-left: -50vw;
    margin-right: -50vw;
    width: 100vw;
    /* Transition only transform for smoother animation */
    overflow: hidden;
    transition: transform 0.3s ease-out;
  }

  .sticky-mini-title.expanded {
    transform: translateY(0);
    height: 3rem;
    transition: transform 0.3s ease-out;
  }

  /* Modify headroom animation for unpinned state to match exact height */
  .headroom--unpinned.headroom {
    transform: translateY(calc(-100% + 3rem)) !important;
  }

  /* Hide main content when unpinned */
  .headroom--unpinned .navbar-main-content {
    display: none !important;
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const navbar = document.querySelector('.navbar-container');
    const template = document.getElementById('sticky-mini-title-template');
    const titleBanner = document.querySelector('.quarto-title-banner .quarto-title .title');
    const abstract = document.querySelector('.abstract');

    if (navbar && template && titleBanner && abstract) {
      // Create wrapper and move existing content
      const wrapper = document.createElement('div');
      wrapper.className = 'navbar-main-content';
      while (navbar.firstChild) {
        wrapper.appendChild(navbar.firstChild);
      }
      navbar.appendChild(wrapper);

      // Add persistent element
      const element = template.content.cloneNode(true);
      navbar.appendChild(element);

      // Get the persistent element after insertion
      const persistentElement = navbar.querySelector('.sticky-mini-title');
      const persistentHeight = 48; // 3rem

      // Track transition state
      let isTransitioning = false;
      persistentElement.addEventListener('transitionend', (e) => {
        if (e.propertyName === 'transform') {
          isTransitioning = false;
        }
      });

      const expandAndScroll = () => {
        if (!persistentElement.classList.contains('expanded')) {
          isTransitioning = true;
          // First frame: add class
          requestAnimationFrame(() => {
            persistentElement.classList.add('expanded');
            // Next frame: scroll
            requestAnimationFrame(() => {
              window.scrollBy({
                top: persistentHeight,
                behavior: 'instant'
              });
            });
          });
        }
      };

      const collapseAndScroll = () => {
        if (persistentElement.classList.contains('expanded')) {
          isTransitioning = true;
          requestAnimationFrame(() => {
            persistentElement.classList.remove('expanded');
            window.scrollBy({
              top: -persistentHeight,
              behavior: 'instant'
            });
          });
        }
      };

      // Create appear observer (triggers when abstract hits top)
      const appearObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach(entry => {
            if (!entry.isIntersecting && entry.boundingClientRect.top <= persistentHeight && !isTransitioning) {
              expandAndScroll();
            }
          });
        },
        {
          threshold: [0],
          rootMargin: "0px"
        }
      );

      // Create disappear observer (original title banner logic)
      const disappearObserver = new IntersectionObserver(
        (entries) => {
          entries.forEach(entry => {
            const visibleHeight = entry.intersectionRect.height;
            if (visibleHeight > persistentHeight && !isTransitioning) {
              collapseAndScroll();
            }
          });
        },
        {
          threshold: Array.from({length: 100}, (_, i) => i / 100),
          rootMargin: "0px"
        }
      );

      // Start observing both elements
      appearObserver.observe(abstract);
      disappearObserver.observe(titleBanner);
    }
  });
</script>
